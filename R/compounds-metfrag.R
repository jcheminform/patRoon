#' @include main.R
#' @include compounds.R
#' @include mspeaklists.R
#' @include formulas.R
NULL

#' Compounds list class for MetFrag results.
#'
#' This class is derived from \code{\link{compounds}} and contains additional
#' specific MetFrag data.
#'
#' Objects from this class are generated by
#' \code{\link{generateCompoundsMetFrag}}
#'
#' @slot settings A list with all general configuration settings passed to
#'   MetFrag. Feature specific items (\emph{e.g.} spectra and precursor masses)
#'   are not contained in this list.
#'
#' @param compoundsMF A \code{compoundsMF} object.
#'
#' @templateVar class compoundsMF
#' @template class-hierarchy
#'
#' @seealso \code{\link{compounds}} and \link{compound-generation}
#'
#' @references \insertRef{Ruttkies2016}{patRoon}
#'
#' @export
compoundsMF <- setClass("compoundsMF", slots = c(settings = "list"),
                        contains = "compounds")

setMethod("initialize", "compoundsMF",
          function(.Object, ...) callNextMethod(.Object, algorithm = "metfrag", ...))


#' @describeIn compoundsMF Accessor method for the \code{settings} slot.
#' @aliases settings
#' @export
setMethod("settings", "compoundsMF", function(compoundsMF) compoundsMF@settings)


unifyMFNames <- function(mfr)
{
    unNames <- c(NoExplPeaks = "explainedPeaks",
                 Score = "score",
                 MonoisotopicMass = "neutralMass",
                 SMILES = "SMILES",
                 InChIKey = "InChIKey",
                 InChIKey2 = "InChIKey2",
                 InChIKey1 = "InChIKey1",
                 InChI = "InChI",
                 Identifier = "identifier",
                 PubChemNumberPatents = "numberPatents",
                 fragInfo = "fragInfo", # keep it
                 FragmenterScore = "fragScore",
                 MolecularFormula = "formula",
                 TrivialName = "compoundName",
                 CompoundName = "compoundName",
                 IUPACName = "compoundName",

                 # PubChem
                 XlogP3 = "XlogP",
                 PubChemNumberPubMedReferences = "pubMedReferences",
                 ChemSpiderNumberPubMedReferences = "pubMedReferences",
                 
                 # PubChemLite
                 FP = "FP",
                 PubMed_Count = "pubMedReferences",
                 Patent_Count = "numberPatents",
                 Related_CIDs = "relatedCIDs",
                 Name2 = "compoundName2", # Nov2019 version
                 Synonym = "compoundName2", # Jan2020 version
                 AgroChemInfo = "agroChemInfo",
                 BioPathway = "bioPathway",
                 DrugMedicInfo = "drugMedicInfo",
                 FoodRelated = "foodRelated",
                 PharmacoInfo = "pharmacoInfo",
                 SafetyInfo = "safetyInfo",
                 ToxicityInfo = "toxicityInfo",
                 DisorderDisease = "disorderDisease",
                 Identification = "identification",
                 KnownUse = "knownUse",
                 FPSum = "annoTypeCount", # Nov2019 version (rename to Jan2020 version)
                 AnnoTypeCount = "annoTypeCount", # Jan2020 version

                 # ChemSpider
                 CHEMSPIDER_XLOGP = "XlogP",
                 CHEMSPIDER_ALOGP = "AlogP",
                 ChemSpiderNumberExternalReferences = "extReferenceCount",
                 ChemSpiderDataSourceCount = "dataSourceCount",
                 ChemSpiderReferenceCount = "referenceCount",
                 ChemSpiderRSCCount = "RSCCount",

                 OfflineMetFusionScore = "metFusionScore",
                 OfflineIndividualMoNAScore = "individualMoNAScore",
                 SmartsSubstructureInclusionScore = "smartsInclusionScore",
                 SmartsSubstructureExclusionScore = "smartsExclusionScore",
                 SuspectListScore = "suspectListScore",
                 RetentionTimeScore = "retentionTimeScore",
                 AutomatedPeakFingerprintAnnotationScore = "peakFingerprintScore",
                 AutomatedLossFingerprintAnnotationScore = "lossFingerprintScore",

                 # CompTox variables
                 CASRN_DTXSID = "CASRN",
                 CPDAT_COUNT = "CPDATCount",
                 ECOTOX = "ECOTOX",
                 NORMANSUSDAT = "NORMANSUSDAT",
                 TOXCAST_PERCENT_ACTIVE = "TOXCASTActive",
                 NUMBER_OF_PUBMED_ARTICLES = "pubMedReferences",
                 MASSBANKEU = "MASSBANKEU",
                 #MONOISOTOPIC_MASS_DTXCID = "neutralMass",
                 QC_LEVEL = "QCLevel",
                 DATA_SOURCES = "dataSources",
                 PUBCHEM_DATA_SOURCES = "pubChemDataSources",
                 TOX21SL = "TOX21SL",
                 "EXPOCAST_MEDIAN_EXPOSURE_PREDICTION_MG/KG-BW/DAY" = "EXPOCASTPredExpo",
                 TOXCAST = "TOXCAST",
                 KEMIMARKET = "KEMIMARKET",
                 MZCLOUD = "MZCLOUD",
                 
                 # CompTox - smoke metadata
                 PubMedNeuro = "pubMedNeuro",
                 CIGARETTES = "CIGARETTES",
                 INDOORCT16 = "INDOORCT16",
                 SRM2585DUST = "SRM2585DUST",
                 SLTCHEMDB = "SLTCHEMDB",
                 THSMOKE = "THSMOKE",
                 
                 # CompTox - wastewater metadata
                 ITNANTIBIOTIC = "ITNANTIBIOTIC",
                 STOFFIDENT = "STOFFIDENT",
                 KEMIMARKET_EXPO = "KEMIMARKET_EXPO",
                 KEMIMARKET_HAZ = "KEMIMARKET_HAZ",
                 REACH2017 = "REACH2017",
                 KEMIWW_WDUIndex = "KEMIWW_WDUIndex",
                 KEMIWW_StpSE = "KEMIWW_StpSE",
                 KEMIWW_SEHitsOverDL = "KEMIWW_SEHitsOverDL",
                 ZINC15PHARMA = "ZINC15PHARMA",
                 PFASMASTER = "PFASMASTER",

                 # FOR-IDENT
                 ForIdentTonnage = "tonnage",
                 ForIdentCategories = "categories"
                 )

    unNames <- unNames[names(unNames) %in% names(mfr)] # filter out missing
    setnames(mfr, names(unNames), unNames)

    return(mfr[, unNames, with = FALSE]) # filter out any other columns
}

# MetFragCL gives bracketed fragment formulas including charge and weird (de)protonation adducts
# For comparison with other results these should be converted to a simple formula format
cleanFragFormulas <- function(forms)
{
    forms <- gsub("\\[|\\]", "", forms) # remove brackets
    forms <- gsub("[-\\+]$", "", forms) # remove trailing charge

    # add single counts to hydrogen adducts without count (e.g. -H becomes -1H)
    forms <- gsub("([-\\+])H", "\\11H", forms)

    adducts <- regmatches(forms, gregexpr("([-\\+][0-9]+)H", forms)) # get "-1H", "+2H" etc

    # Get 'regular' part of formula and update H count
    baseForms <- gsub("^([[:alnum:]]+)[-|\\+].*", "\\1", forms)

    return(sapply(seq_along(forms), function(fi)
    {
        addHCount <- sum(as.integer(gsub("H", "", adducts[[fi]])))
        flist <- splitFormulaToList(baseForms[[fi]])

        if (addHCount != 0)
        {
            if (!"H" %in% names(flist))
            {
                flist <- c(flist, addHCount)
                names(flist)[length(flist)] <- "H"
            }
            else
                flist[["H"]] <- flist[["H"]] + addHCount
        }
        return(formulaListToString(flist))
    }))
}

getMFFragmentInfo <- function(spec, mfResult, adduct)
{
    if (mfResult$NoExplPeaks == 0 || mfResult$FormulasOfExplPeaks == "NA")
        return(data.table(mz = numeric(0), formula = character(0), score = numeric(0), PLIndex = numeric(0)))

    # format of FormulasOfExplPeaks: list of strings with mz1:formula1;mz2:formula2;...
    fi <- unlist(strsplit(mfResult$FormulasOfExplPeaks, "[;:]")) # split into list with subsequent m/z / formula pairs

    ret <- data.table(mz = as.numeric(fi[c(TRUE, FALSE)]),
                      formula = cleanFragFormulas(fi[c(FALSE, TRUE)]))
    if (!is.null(mfResult[["FragmenterScore_Values"]]))
        ret[, score := as.numeric(unlist(strsplit(mfResult$FragmenterScore_Values, ";")))]
    ionform <- calculateIonFormula(mfResult$MolecularFormula, adduct)
    ret[, neutral_loss := sapply(formula, subtractFormula, formula1 = ionform)]
    ret[, PLIndex := sapply(mz, function(omz) which.min(abs(omz - spec$mz)))]
    ret[, intensity := spec$intensity[PLIndex]]
    setcolorder(ret, c("mz", "formula", "neutral_loss", "intensity"))

    return(ret)
}

isLocalMetFragDB <- function(database) database %in% c("sdf", "psv", "csv", "comptox", "pubchemlite")

getMetFragExtDB <- function(localDB, database)
{
    extDB <- if (!is.null(localDB)) localDB else NULL
    if ((database == "comptox" || database == "pubchemlite") && is.null(extDB))
        extDB <- getOption(if (database == "comptox") "patRoon.path.MetFragCompTox" else "patRoon.path.MetFragPubChemLite", NULL)
    
    if (!is.null(extDB))
        extDB <- normalizePath(extDB)
    
    if (is.null(extDB) || !file.exists(extDB))
    {
        ex <- "as part of the extraOpts argument, e.g. extraOpts = list(LocalDatabasePath = \"C:/CompTox_17March2019_SelectMetaData.csv\")"
        if (database == "comptox" || database == "pubchemlite")
            stop(paste("No (valid) external database file set. This should be either set as an option, e.g.",
                       "options(patRoon.path.MetFragCompTox = \"C:/CompTox_17March2019_SelectMetaData.csv\") or", ex))
        
        stop(paste("No external database file set. This should be set", ex))
    }
    
    return(extDB)
}

initMetFragCLCommand <- function(mfSettings, spec, mfBin)
{
    paramFile <- tempfile("parameters", fileext = ".txt")
    paramCon <- file(paramFile, "w")

    writeParam <- function(param, val) cat(sprintf("%s = %s\n", param, paste0(as.character(val), collapse = ",")), file = paramCon)

    for (param in names(mfSettings))
        writeParam(param, mfSettings[[param]])

    outFile <- tempfile("results", fileext = ".csv")
    writeParam("MetFragCandidateWriter", "CSV")
    writeParam("SampleName", basename(tools::file_path_sans_ext(outFile)))
    writeParam("ResultsPath", dirname(outFile))

    specFile <- tempfile("spectrum", fileext = ".txt")
    write.table(spec[, c("mz", "intensity")], specFile, sep = "\t", row.names = FALSE, col.names = FALSE)
    writeParam("PeakListPath", specFile)

    close(paramCon)

    return(list(command = "java", args = c("-jar", mfBin, paramFile), outFile = outFile))
}

generateMetFragRunData <- function(fGroups, MSPeakLists, mfSettings, extDB, topMost, identifiers, method,
                                   adduct, database, errorRetries, timeoutRetries)
{
    gNames <- names(fGroups)
    gTable <- groupTable(fGroups)
    gInfo <- groupInfo(fGroups)
    anaInfo <- analysisInfo(fGroups)
    
    baseHash <- makeHash(method, topMost)
    if (!is.null(extDB))
        baseHash <- makeHash(baseHash, extDB)

    ret <- sapply(gNames, function(grp)
    {
        if (!is.null(identifiers) && is.null(identifiers[[grp]]))
            return(NULL)

        spec <- MSPeakLists[[grp]][["MSMS"]]
        if (is.null(spec))
            return(NULL)

        mfSettings$IonizedPrecursorMass <- gInfo[grp, "mzs"]
        mfSettings$ExperimentalRetentionTimeValue <- gInfo[grp, "rts"] / 60

        if (!is.null(identifiers))
            mfSettings$PrecursorCompoundIDs <- identifiers[[grp]]

        hash <- makeHash(baseHash, mfSettings, spec)

        logf <- paste0("mfcl-", grp, ".txt")
        
        return(list(hash = hash, gName = grp, spec = spec, mfSettings = mfSettings,
                    adduct = adduct, database = database, topMost = topMost,
                    errorRetries = errorRetries, timeoutRetries = timeoutRetries,
                    logFile = logf))
    }, simplify = FALSE)

    return(ret[!sapply(ret, is.null)])
}

processMFResults <- function(comptab, runData, lfile = "")
{
    scRanges <- list()

    if (nrow(comptab) > 0)
    {
        compsc <- compoundScorings("metfrag")
        compsc <- compsc[compsc$metfrag %in% names(comptab), ]

        if (nrow(compsc) > 0)
        {
            # fix up score and suspect list columns: dash --> 0
            # NOTE: do as.numeric as values with '-' will cause the column to be a character
            comptab[, (compsc$metfrag) := lapply(.SD, function(x) as.numeric(ifelse(x == "-", 0, x))),
                    .SDcols = compsc$metfrag]

            scRanges <- setNames(lapply(compsc$metfrag, function(sc) range(comptab[[sc]])),
                                 compsc$name)
        }

        if (!is.null(runData$topMost) && nrow(comptab) > runData$topMost)
            comptab <- comptab[seq_len(runData$topMost)]

        # make character: needed for getMFFragmentInfo()
        # note: this column is not present in empty tables so can't do this with colClasses
        if (!is.null(comptab[["FragmenterScore_Values"]]))
            comptab[, FragmenterScore_Values := as.character(FragmenterScore_Values)]

        # fill in fragment info
        # NOTE: double wrap in list to nest table
        if (!is.null(lfile))
            cat(sprintf("\n%s - Done! Processing frags...\n", date()), file = lfile, append = TRUE)
        for (r in seq_len(nrow(comptab)))
            set(comptab, r, "fragInfo", list(list(getMFFragmentInfo(runData$spec, comptab[r], runData$adduct))))
        if (!is.null(lfile))
            cat(sprintf("\n%s - Done!\n", date()), file = lfile, append = TRUE)

        # unify column names & filter unnecessary columns
        comptab <- unifyMFNames(comptab)

        if (!is.null(comptab[["CASRN"]]))
            comptab[, CASRN := sub("CASRN:", "", CASRN, fixed = TRUE)] # remove "CASRN" prefix
        
        # sometimes these can be interpreted as dates!
        for (col in c("compoundName", "compoundName2", "CASRN"))
        {
            if (!is.null(comptab[[col]]))
                comptab[, (col) := as.character(get(col))]
        }

        comptab[, database := runData$database]
    }

    return(list(comptab = comptab, scRanges = scRanges))
}

MFMPFinishHandler <- function(cmd)
{
    comptab <- data.table::fread(cmd$outFile, colClasses = c(Identifier = "character"))
    procres <- patRoon:::processMFResults(comptab, cmd, cmd$stderrFile)
    return(procres)
}

MFMPPrepareHandler <- function(cmd)
{
    mfBin <- path.expand(getOption("patRoon.path.MetFragCL"))
    if (is.null(mfBin) || !nzchar(mfBin) || !file.exists(mfBin))
        stop("Please set the 'MetFragCL' option with a (correct) path to the MetFrag CL jar file. Example: options(patRoon.path.MetFragCL = \"C:/MetFrag2.4.5-CL.jar\")")
    
    if (!nzchar(Sys.which("java")))
        stop("Please make sure that java is installed and its location is correctly set in PATH.")
    
    if (isLocalMetFragDB(cmd$database))
    {
        extDB <- patRoon:::getMetFragExtDB(cmd$mfSettings[["LocalDatabasePath"]], cmd$database)
        # NOTE: this will set LocalDatabasePath in case only options() were set or update it with normalizePath()
        cmd$mfSettings$LocalDatabasePath <- normalizePath(extDB)
    }
    
    return(c(cmd, patRoon:::initMetFragCLCommand(cmd$mfSettings, cmd$spec, mfBin)))
}

MFMPTimeoutHandler <- function(cmd, retries)
{
    if (retries >= cmd$timeoutRetries)
    {
        warning(sprintf("Could not run MetFrag for %s: timeout. Log: %s", cmd$gName, cmd$logFile))
        return(FALSE)
    }
    warning(sprintf("Restarting timed out MetFrag command for %s (retry %d/%d)",
                    cmd$gName, retries+1, cmd$timeoutRetries))
    return(TRUE)
}

MFMPErrorHandler <- function(cmd, exitStatus, retries)
{
    if (!is.na(exitStatus) && exitStatus <= 6) # some error thrown by MF
    {
        if (retries >= cmd$errorRetries)
        {
            warning(sprintf("Could not run MetFrag for %s - exit code: %d - Log: %s",
                            cmd$gName, exitStatus, cmd$logFile))
            return(FALSE)
        }
        warning(sprintf("Restarting failed MetFrag command for %s - exit: %d (retry %d/%d)",
                        cmd$gName, exitStatus, retries+1, cmd$errorRetries))
        return(TRUE)
    }
    
    # some other error (e.g. java not present)
    return(sprintf("Fatal: Failed to execute MetFragCL for %s - exit code: %d - Log: %s",
                   cmd$gName, exitStatus, cmd$logFile))
}

#' @details \code{generateCompoundsMetFrag} uses the \pkg{metfRag} package or
#'   \command{MetFrag CL} for compound identification (see
#'   \url{http://ipb-halle.github.io/MetFrag/}). Several online compound
#'   databases such as \href{https://pubchem.ncbi.nlm.nih.gov/}{PubChem} and
#'   \href{http://www.chemspider.com/}{ChemSpider} may be chosen for retrieval
#'   of candidate structures. In addition, many options exist to score and
#'   filter resulting data, and it is highly suggested to optimize these to
#'   improve results. While MS/MS data is not mandatory, it will usually greatly
#'   improve candidate scoring. The \command{MetFrag} options \code{PeakList},
#'   \code{IonizedPrecursorMass} and \code{ExperimentalRetentionTimeValue} (in
#'   minutes) fields are automatically set from feature data.
#'
#' @param method Which method should be used for MetFrag execution: \code{"CL"}
#'   for \command{MetFragCL} and \code{"R"} for \command{MetFragR}. The former
#'   might be faster.
#' @param timeout Maximum time (in seconds) before a metFrag query for a feature
#'   group is stopped. Also see \code{timeoutRetries} argument.
#' @param timeoutRetries Maximum number of retries after reaching a timeout
#'   before completely skipping the metFrag query for a feature group. Also see
#'   \code{timeout} argument.
#' @param dbRelMzDev Relative mass deviation (in ppm) for database search. Sets
#'   the \option{DatabaseSearchRelativeMassDeviation} option.
#' @param fragRelMzDev Relative mass deviation (in ppm) for fragment matching.
#'   Sets the \option{FragmentPeakMatchRelativeMassDeviation} option.
#' @param fragAbsMzDev Absolute mass deviation (in Da) for fragment matching.
#'   Sets the \option{FragmentPeakMatchAbsoluteMassDeviation} option.
#' @param database Compound database to use. Valid values are: \code{"pubchem"},
#'   \code{"chemspider"}, \code{"for-ident"}, \code{"comptox"},
#'   \code{"pubchemlite"}, \code{"kegg"}, \code{"sdf"}, \code{"psv"} and
#'   \code{"csv"}. See section below for more information. Sets the
#'   \code{MetFragDatabaseType} option.
#' @param extendedPubChem If \code{database="pubchem"}: whether to use the
#'   \emph{extended} database that includes information for compound scoring
#'   (\emph{i.e.} number of patents/PubMed references). Note that downloading
#'   candidates from this database might take extra time. Valid values are:
#'   \code{FALSE} (never use it), \code{TRUE} (always use it) or \code{"auto"}
#'   (default, use if specified scorings demand it).
#' @param chemSpiderToken A character string with the
#'   \href{http://www.chemspider.com/AboutServices.aspx}{ChemSpider security
#'   token} that should be set when the ChemSpider database is used. Sets the
#'   \option{ChemSpiderToken} option.
#' @param scoreTypes A character vector defining the scoring types. See the
#'   \verb{Scorings} section below for more information. Note that both generic
#'   and \command{MetFrag} specific names are accepted (\emph{i.e.} \code{name}
#'   and \code{metfrag} columns returned by \code{compoundScorings}). When a
#'   local database is used, the name should match what is given there
#'   (\code{e.g} column names when \code{database=csv}). Note that MetFrag may
#'   still report other scoring data, however, these are not used for ranking.
#'   Sets the \option{MetFragScoreTypes} option.
#' @param scoreWeights Numeric vector containing weights of the used scoring
#'   types. Order is the same as set in \code{scoreTypes}. Values are recycled
#'   if necessary. Sets the \option{MetFragScoreWeights} option.
#' @param preProcessingFilters,postProcessingFilters A character vector defining
#'   pre/post filters applied before/after fragmentation and scoring
#'   (\emph{e.g.} \code{"UnconnectedCompoundFilter"}, \code{"IsotopeFilter"},
#'   \code{"ElementExclusionFilter"}). Some methods require further options to
#'   be set. For all filters and more information refer to the \verb{Candidate
#'   Filters} section on the
#'   \href{http://ipb-halle.github.io/MetFrag/projects/metfragr/}{MetFragR
#'   homepage}. Sets the \option{MetFragPreProcessingCandidateFilter} and
#'   \code{MetFragPostProcessingCandidateFilter} options.
#' @param maxCandidatesToStop If more than this number of candidate structures
#'   are found then processing will be aborted and no results this feature group
#'   will be reported. Low values increase the chance of missing data, whereas
#'   too high values will use too much computer resources and signficantly
#'   slowdown the process. Sets the \option{MaxCandidateLimitToStop} option.
#' @param identifiers A \code{list} containing for each feature group a
#'   character vector with database identifiers that should be used to find
#'   candidates for a feature group (the list should be named by feature group
#'   names). If \code{NULL} all relevant candidates will be retrieved from the
#'   specified database. An example usage scenario is to obtain the list of
#'   candidate identifiers from a \code{\link{compounds}} object obtained with
#'   \code{\link{generateCompoundsSIRIUS}} using the \code{\link{identifiers}}
#'   method. This way, only those candidates will be searched by MetFrag that
#'   were generated by SIRIUS+CSI:FingerID. Sets the
#'   \option{PrecursorCompoundIDs} option.
#'
#' @return \code{generateCompoundsMetFrag} returns a \code{\link{compoundsMF}}
#'   object.
#'
#' @section Usage of MetFrag databases: When \code{database="chemspider"}
#'   setting the \code{chemSpiderToken} argument is mandatory.
#'
#'   When a local database is set (\emph{i.e.} \code{sdf}, \code{psv},
#'   \code{csv}, \code{comptox}, \code{pubchemlite}) the file location of the
#'   database should be set in the \code{LocalDatabasePath} value via the
#'   \code{extraOpts} argument or using the
#'   \code{patRoon.path.MetFragCompTox}/\code{patRoon.path.MetFragPubChemLite}
#'   option (only when \code{database="comptox"} or
#'   \code{database="pubchemlite"}).
#'
#'   Examples: \verb{options(patRoon.path.MetFragCompTox =
#'   "C:/CompTox_17March2019_SelectMetaData.csv")} \verb{extraOpts =
#'   list(LocalDatabasePath = "C:/myDB.csv")}.
#'
#'   For \code{database="comptox"} the files can be obtained from
#'   \href{ftp://newftp.epa.gov/COMPTOX/Sustainable_Chemistry_Data/Chemistry_Dashboard/MetFrag_metadata_files}{here}.
#'    Furthermore, the files with additions for
#'   \href{smoking}{https://zenodo.org/record/3364464#.XnjM-XLvKUk} and
#'   \href{wastewater}{https://zenodo.org/record/3472781#.XnjMAHLvKUk} metadata
#'   are also supported. Note that only recent \command{MetFrag} versions (>=
#'   \samp{2.4.5}) support these libraries.
#'   
#' @section Parallelization: When local database files are used with
#'   \code{generateCompoundsMetFrag} (\emph{e.g.} when \code{database} is set to
#'   \code{"pubchemlite"}, \code{"csv"} etc.) and
#'   \option{patRoon.MP.method="future"}, then the database file must be present
#'   on all the nodes. When \code{pubchemlite} or \code{comptox} is used, the
#'   location for these databases can be configured on the host with the
#'   respective package options (\option{patRoon.path.MetFragPubChemLite} and
#'   \option{patRoon.path.MetFragCompTox}). Note that these files must
#'   \emph{also} be present on the local host computer, even if it is not
#'   participating in computations.
#'
#' @references \insertRef{Ruttkies2016}{patRoon}
#'
#' @rdname compound-generation
#' @export
generateCompoundsMetFrag <- function(fGroups, MSPeakLists, method = "CL", timeout = 300,
                                     timeoutRetries = 2, errorRetries = 2, topMost = 100,
                                     dbRelMzDev = 5, fragRelMzDev = 5, fragAbsMzDev = 0.002, adduct,
                                     database = "pubchem", extendedPubChem = "auto", chemSpiderToken = "",
                                     scoreTypes = compoundScorings("metfrag", database, onlyDefault = TRUE)$name,
                                     scoreWeights = 1.0,
                                     preProcessingFilters = c("UnconnectedCompoundFilter", "IsotopeFilter"),
                                     postProcessingFilters = c("InChIKeyFilter"),
                                     maxCandidatesToStop = 2500, identifiers = NULL, extraOpts = NULL)
{
    if (method == "R")
        checkPackage("metfRag", "c-ruttkies/MetFragR")

    ac <- checkmate::makeAssertCollection()
    checkmate::assertClass(fGroups, "featureGroups", add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertChoice(method, c("CL", "R"), add = ac)
    aapply(checkmate::assertNumber, . ~ timeout + dbRelMzDev + fragRelMzDev + fragAbsMzDev,
           lower = 0, finite = TRUE, fixed = list(add = ac))
    aapply(checkmate::assertCount, . ~ timeoutRetries + errorRetries, fixed = list(add = ac))
    aapply(checkmate::assertCount, . ~ topMost + maxCandidatesToStop, positive = TRUE, fixed = list(add = ac))
    checkmate::assertString(chemSpiderToken, add = ac)
    checkmate::assertChoice(database, c("pubchem", "chemspider", "kegg", "for-ident", "sdf", "psv", "csv",
                                        "comptox", "pubchemlite"), add = ac)
    checkmate::assert(checkmate::checkFlag(extendedPubChem),
                      checkmate::checkChoice(extendedPubChem, "auto"),
                      .var.name = "extendedPubChem")
    aapply(checkmate::assertCharacter, . ~ scoreTypes + preProcessingFilters + postProcessingFilters,
           any.missing = FALSE, fixed = list(add = ac))
    checkmate::assertNumeric(scoreWeights, lower = 0, finite = TRUE, any.missing = FALSE, min.len = 1, add = ac)
    aapply(checkmate::assertList, . ~ identifiers + extraOpts, any.missing = FALSE,
           names = "unique", null.ok = TRUE, fixed = list(add = ac))

    compsScores <- compoundScorings("metfrag", database)
    isLocalDB <- isLocalMetFragDB(database)
    allScoringNames <- union(compsScores$name, compsScores$metfrag)
    # allow freely definable scorings from local databases
    if (!isLocalDB)
        checkmate::assertSubset(scoreTypes, allScoringNames, add = ac)

    checkmate::reportAssertions(ac)

    adduct <- checkAndToAdduct(adduct)

    anaInfo <- analysisInfo(fGroups)
    ftind <- groupFeatIndex(fGroups)
    gTable <- groupTable(fGroups)
    gNames <- names(fGroups)
    gCount <- length(fGroups)
    gInfo <- groupInfo(fGroups)
    pLists <- peakLists(MSPeakLists)

    if (!is.logical(extendedPubChem) && database == "pubchem")
    {
        PCScorings <- compoundScorings("metfrag", "pubchem", includeNoDB = FALSE)
        extendedPubChem <- any(scoreTypes %in% union(PCScorings$name, PCScorings$metfrag))
    }

    # convert to metfrag naming scheme
    databaseMF <- switch(database,
                         pubchem = "PubChem",
                         chemspider = "ChemSpider",
                         kegg = "KEGG",
                         "for-ident" = "FOR-IDENT",
                         sdf = "LocalSDF",
                         psv = "LocalPSV",
                         csv = "LocalCSV",
                         comptox = "LocalCSV",
                         pubchemlite = "LocalCSV")
    if (databaseMF == "PubChem" && extendedPubChem) # can't seem to combine this conditional in above switch...
        databaseMF <- "ExtendedPubChem"

    scoreTypesMF <- setdiff(scoreTypes, c("score", "Score")) # final score is to be determined
    isSimplScore <- scoreTypesMF %in% compsScores$name
    if (any(isSimplScore))
        scoreTypesMF[isSimplScore] <- compsScores[match(scoreTypesMF[isSimplScore], compsScores$name), "metfrag"]

    scoreWeights <- rep(scoreWeights, length.out = length(scoreTypesMF))
    
    extDB <- NULL
    if (isLocalDB)
    {
        extDB <- getMetFragExtDB(extraOpts[["LocalDatabasePath"]], database)
        
        # only keep scorings that are present in the DB
        # BUG: nrows=0 gives internal data.table error, so read 1 line
        scInDB <- names(fread(extDB, nrows = 1))
        
        isDBType <- scoreTypesMF %in% compsScores[nzchar(compsScores$database), "metfrag"]
        keep <- !isDBType | scoreTypesMF %in% scInDB

        scoreTypesMF <- scoreTypesMF[keep]; scoreWeights <- scoreWeights[keep]
    }
    
    mfSettings <- list(DatabaseSearchRelativeMassDeviation = dbRelMzDev,
                       FragmentPeakMatchRelativeMassDeviation = fragRelMzDev,
                       FragmentPeakMatchAbsoluteMassDeviation = fragAbsMzDev,
                       PrecursorIonType = as.character(adduct, format = "metfrag"),
                       MetFragDatabaseType = databaseMF, MetFragScoreTypes = scoreTypesMF,
                       MetFragScoreWeights = scoreWeights,
                       MetFragPreProcessingCandidateFilter = preProcessingFilters,
                       MetFragPostProcessingCandidateFilter = postProcessingFilters,
                       MaxCandidateLimitToStop = maxCandidatesToStop)

    if (!is.null(chemSpiderToken) && nzchar(chemSpiderToken))
        mfSettings$ChemSpiderToken <- chemSpiderToken

    if (!is.null(extraOpts))
    {
        # add (or replace) any extra options
        mfSettings <- modifyList(mfSettings, extraOpts)
    }

    setHash <- makeHash(fGroups, pLists, method, mfSettings, topMost, identifiers)
    if (!is.null(extDB))
        setHash <- makeHash(setHash, makeFileHash(extDB))
    
    printf("Identifying %d feature groups with MetFrag...\n", gCount)

    runData <- generateMetFragRunData(fGroups, MSPeakLists, mfSettings, extDB, topMost, identifiers, method,
                                      adduct, database, errorRetries, timeoutRetries)

    if (method == "CL")
    {
        results <- executeMultiProcess(runData, finishHandler = patRoon:::MFMPFinishHandler,
                                       timeoutHandler = patRoon:::MFMPTimeoutHandler,
                                       errorHandler = patRoon:::MFMPErrorHandler,
                                       prepareHandler = patRoon:::MFMPPrepareHandler,
                                       cacheName = "metfrag", setHash = setHash,
                                       procTimeout = timeout, delayBetweenProc = 1000,
                                       logSubDir = "metfrag")
    }
    else
    {
        cacheDB <- openCacheDBScope()
        cachedSet <- loadCacheSet("compoundsMetFrag", setHash, cacheDB)
        resultHashes <- vector("character", length(gNames))
        names(resultHashes) <- gNames
        
        cachedResults <- sapply(runData, function(rd)
        {
            resultHashes[rd$gName] <<- rd$hash
            comptab <- NULL
            if (!is.null(cachedSet))
                comptab <- cachedSet[[rd$hash]]
            if (is.null(comptab))
                comptab <- loadCacheData("compoundsMetFrag", rd$hash, cacheDB)
            return(comptab)
        }, simplify = FALSE)
        cachedResults <- cachedResults[!sapply(cachedResults, is.null)]
        
        runData <- runData[setdiff(names(runData), names(cachedResults))] # remove cached results
        
        if (length(runData) > 0)
        {
            prog <- openProgBar(0, gCount)
            
            results <- lapply(runData, function(rd)
            {
                rd$mfSettings$PeakList <- as.matrix(rd$spec[, c("mz", "intensity")])
                comptab <- metfRag::run.metfrag(rd$mfSettings)
                jgc() # hopefully reduce some memory usage
                
                if (nrow(comptab) > 0)
                    comptab <- unFactorDF(comptab)
                
                comptab <- as.data.table(comptab)
                
                procres <- processMFResults(comptab, rd)
                
                if (nrow(procres$comptab) > 0)
                {
                    # BUG: metfRag seems to give second duplicate results where only NoExplPeaks may differ and have an incorrect value.
                    # for now, just remove all duplicates and re-assign NoExplPeaks
                    procres$comptab <- procres$comptab[!duplicated(identifier)]
                    procres$comptab[, explainedPeaks := sapply(fragInfo, nrow)]
                }
                
                saveCacheData("compoundsMetFrag", procres, rd$hash, cacheDB)
                
                setTxtProgressBar(prog, match(rd$gName, gNames))
                
                return(procres)
            })
            
            setTxtProgressBar(prog, gCount)
            close(prog)
        }
        else
            results <- list()
        
        if (length(cachedResults) > 0)
        {
            results <- c(results, cachedResults)
            results <- results[intersect(gNames, names(results))] # re-order
        }
        
        if (is.null(cachedSet))
            saveCacheSet("compoundsMetFrag", resultHashes[nzchar(resultHashes)], setHash, cacheDB)
    }
    
    # prune empty/NULL results
    if (length(results) > 0)
        results <- results[sapply(results, function(r) !is.null(r$comptab) && nrow(r$comptab) > 0, USE.NAMES = FALSE)]

    ngrp <- length(results)
    printf("Loaded %d compounds from %d features (%.2f%%).\n", sum(unlist(lapply(results, function(r) nrow(r$comptab)))),
           ngrp, if (gCount == 0) 0 else ngrp * 100 / gCount)

    # convert scoreTypes to generic names
    scoreTypes <- union(scoreTypes, "score") # ensure final score is in and remove duplicates
    isMFScore <- scoreTypes %in% compsScores$metfrag
    if (any(isMFScore))
        scoreTypes[isMFScore] <- compsScores[match(scoreTypes[isMFScore], compsScores$metfrag), "name"]

    return(compoundsMF(compounds = lapply(results, "[[", "comptab"), scoreTypes = scoreTypes,
                       scoreRanges = lapply(results, "[[", "scRanges"),
                       settings = mfSettings))
}
