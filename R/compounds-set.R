#' @include main.R
#' @include compounds.R
#' @include workflow-step-set.R
NULL

makeCompoundsSetConsensus <- function(setObjects, origFGNames, setThreshold)
{
    # generate consensus by...
    # - checking setThreshold
    # - merging by identifier
    # - average scores
    # - merge fragInfos and update PLIndex
    
    # get all annotated fGroup names with original order
    allAnnGNames <- intersect(origFGNames, unique(unlist(lapply(setObjects, groupNames))))
    
    cons <- sapply(allAnnGNames, function(gName)
    {
        allResults <- pruneList(sapply(setObjects, "[[", gName, simplify = FALSE))
        if (length(allResults) == 1)
            return(copy(allResults[[1]])[, c("setCoverage", "set", "setCount") := .(1, names(allResults)[1], 1)])
        
        allResults <- lapply(allResults, copy)
        
        # init set names
        allResults <- mapply(allResults, names(allResults), FUN = set, SIMPLIFY = FALSE,
                             MoreArgs = list(i = NULL, j = "set"))

        Reduce(x = allResults, f = function(left, right)
        {
            merged <- copy(left)
            
            if (is.null(merged[["setCoverage"]]))
                merged[, c("setCoverage", "setCount") := .(1, 1)]
            
            # UNDONE: assume score cols are same for left/right, should always be the case?

            # merge overlapping candidates: average scores, combine set names and merge fragInfos
            scoreCols <- getAllCompCols(getCompScoreColNames(), names(left), NULL)
            merged[right, (c(scoreCols, "set", "fragInfo")) :=
                       c(lapply(scoreCols, function(sc) .rowMeans(unlist(mget(c(sc, paste0("i.", sc)), inherits = TRUE)), na.rm = TRUE, m = .N, n = 2)),
                         list(paste0(set, ",", i.set),
                              mapply(fragInfo, i.fragInfo, SIMPLIFY = FALSE, FUN = rbind, MoreArgs = list(fill = TRUE)))),
                   on = "identifier"]
            
            # add missing candidates from right
            merged <- rbind(merged, right[!identifier %in% merged$identifier], fill = TRUE)
            
            merged[identifier %in% right$identifier, setCoverage := setCoverage + 1]
            merged[, setCount := setCount + 1]
            
            # re-sort
            setorderv(merged, "score", order = -1)
            
            merged[, fragInfo := lapply(fragInfo, function(fi) fi[, c("PLIndex", "PLIndexSet") := .(PLIndexSet, NULL)])]
            
            return(merged)
        })
    }, simplify = FALSE)
    
    # convert absolute merge counts to coverage
    cons <- lapply(cons, function(ct) ct[, c("setCoverage", "setCount") := .(setCoverage / setCount, NULL)])
    
    if (setThreshold > 0)
        cons <- pruneList(lapply(cons, function(ct) ct[setCoverage >= setThreshold]), checkZeroRows = TRUE)
 
    return(cons)   
}

makeCompoundsSetScorings <- function(setObjects, origFGNames)
{
    scTypes <- character()
    if (length(setObjects) > 0)
        scTypes <- unique(unlist(lapply(setObjects, slot, "scoreTypes")))
    
    scRanges <- list()
    if (length(setObjects) > 0)
    {
        scRanges <- Reduce(x = lapply(setObjects, slot, "scoreRanges"), f = function(left, right)
        {
            # change ranges for overlap
            groupsLR <- intersect(names(left), names(right))
            ret <- mapply(left[groupsLR], right[groupsLR], SIMPLIFY = FALSE, FUN = function(rangesL, rangesR)
            {
                scLR <- names(rangesL) # should be same for left/right
                mapply(rangesL[scLR], rangesR[scLR], FUN = range, SIMPLIFY = FALSE)
            })
            
            # add unique from left
            groupsOnlyL <- setdiff(names(left), names(right))
            ret[groupsOnlyL] <- left[groupsOnlyL]
            
            # add unique from right
            groupsOnlyR <- setdiff(names(right), names(left))
            ret[groupsOnlyR] <- right[groupsOnlyR]
            
            return(ret[intersect(origFGNames, names(ret))]) # order
        })
    }
    
    return(list(scTypes = scTypes, scRanges = scRanges))
}

syncCompoundsSetObjects <- function(compoundsSet, makeCons)
{
    if (makeCons)
        compoundsSet@compounds <- makeCompoundsSetConsensus(compoundsSet@setObjects, compoundsSet@origFGNames,
                                                            compoundsSet@setThreshold)
    else
    {
        # sync available feature groups
        allFGroups <- unique(sapply(setObjects(compoundsSet), groupNames))
        compoundsSet@compounds <- compoundsSet@compounds[intersect(groupNames(compoundsSet), allFGroups)]
        
        # only keep results from sets still present
        compoundsSet@compounds <- lapply(compoundsSet@compounds, function(ct) ct[set %in% sets(compoundsSet)])
    }
    
    compoundsSet@scoreRanges <- compoundsSet@scoreRanges[groupNames(compoundsSet)]
    compoundsSet@adducts <- compoundsSet@adducts[names(compoundsSet@setObjects)]
    
    # update scoreTypes/scoreRanges
    sc <- makeCompoundsSetScorings(setObjects(compoundsSet), compoundsSet@origFGNames)
    compoundsSet@scoreTypes <- sc$scTypes
    compoundsSet@scoreRanges <- sc$scRanges
    
    return(compoundsSet)
}

compoundsSet <- setClass("compoundsSet", slots = c(setThreshold = "numeric", origFGNames = "character"),
                        contains = c("compounds", "workflowStepSet"))

#' @describeIn compoundsSet Shows summary information for this object.
#' @export
setMethod("show", "compoundsSet", function(object)
{
    callAllNextMethods(object, show, firstClass = "compounds", startFrom = "compoundsSet")
})

setMethod("[", c("compoundsSet", "ANY", "missing", "missing"), function(x, i, j, ..., sets = NULL, drop = TRUE)
{
    assertSets(x, sets, TRUE)
    
    if (!is.null(sets))
        x@setObjects <- x@setObjects[sets]
    
    if (!missing(i))
    {
        # NOTE: assume that subsetting with non-existing i will not result in errors
        i <- assertSubsetArgAndToChr(i, groupNames(x))
        x@setObjects <- lapply(x@setObjects, "[", i = i)
        x@setObjects <- pruneList(x@setObjects, checkEmptyElements = TRUE)
    }
    
    if (!is.null(sets) || !missing(i))
        x <- syncCompoundsSetObjects(x, FALSE)
    
    return(x)
})

#' @export
setMethod("filter", "compoundsSet", function(obj, ..., negate = FALSE, sets = NULL)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertFlag(negate, add = ac)
    assertSets(obj, sets, TRUE, add = ac)
    checkmate::reportAssertions(ac)
    
    if (!is.null(sets) && length(sets) > 0)
    {
        if (negate)
            sets <- setdiff(get("sets", pos = 2)(obj), sets)
        obj <- obj[, sets = sets]
    }
    
    if (...length() > 0)
    {
        # filter set objects and re-generate annotation consensus
        
        obj@setObjects <- lapply(obj@setObjects, filter, ..., negate = negate)
        obj@setObjects <- pruneList(obj@setObjects, checkEmptyElements = TRUE)
        
        # synchronize other objects
        cat("Synchronizing set objects...\n")
        obj <- syncCompoundsSetObjects(obj, TRUE)
        cat("Done!\n")
    }
    
    return(obj)
})

#' @export
setMethod("plotSpectrum", "compoundsSet", function(obj, index, groupName, MSPeakLists, formulas = NULL,
                                                   plotStruct = TRUE, title = NULL, useGGPlot2 = FALSE, xlim = NULL,
                                                   ylim = NULL, maxMolSize = c(0.2, 0.4), molRes = c(100, 100),
                                                   perSet = TRUE, mirror = TRUE, ...)
{
    ac <- checkmate::makeAssertCollection()
    checkmate::assertCount(index, positive = TRUE, add = ac)
    checkmate::assertString(groupName, min.chars = 1, add = ac)
    checkmate::assertClass(MSPeakLists, "MSPeakLists", add = ac)
    checkmate::assertClass(formulas, "formulas", null.ok = TRUE, add = ac)
    aapply(checkmate::assertFlag, . ~ plotStruct + useGGPlot2 + perSet + mirror, fixed = list(add = ac))
    assertXYLim(xlim, ylim, add = ac)
    aapply(checkmate::assertNumeric, . ~ maxMolSize + molRes, finite = TRUE, len = 2, fixed = list(add = ac))
    checkmate::reportAssertions(ac)
    
    if (!perSet || length(sets(obj)) == 1)
        return(callNextMethod(obj, index, groupName, MSPeakLists, formulas,
                              plotStruct, title, useGGPlot2, xlim, ylim, maxMolSize, molRes, ...))
    
    spec <- annotatedPeakList(obj, index, groupName, MSPeakLists, formulas)
    if (is.null(spec))
        return(NULL)

    compr <- obj[[groupName]][index, ]    
    mol <- NULL
    if (plotStruct)
    {
        mol <- getMoleculesFromSMILES(compr$SMILES)
        if (!isValidMol(mol))
            mol <- NULL
    }
    
    if (is.null(title))
        title <- getCompoundsSpecPlotTitle(compr$compoundName, compr$formula)
    
    return(makeMSPlotSets(spec, title, mirror, sets(obj), xlim, ylim, useGGPlot2, ..., mol = mol,
                          maxMolSize = maxMolSize, molRes = molRes))
})

setMethod("plotSpectrumHash", "compoundsSet", function(obj, index, groupName, MSPeakLists, formulas = NULL,
                                                       plotStruct = TRUE, title = NULL, useGGPlot2 = FALSE, xlim = NULL,
                                                       ylim = NULL, maxMolSize = c(0.2, 0.4), molRes = c(100, 100),
                                                       perSet = TRUE, mirror = TRUE, ...)
{
    return(makeHash(callNextMethod(obj, index, groupName, MSPeakLists, formulas,
                                   plotStruct, title, useGGPlot2, xlim,
                                   ylim, maxMolSize, molRes, ...),
                    perSet, mirror))
})

setMethod("annotatedPeakList", "compoundsSet", function(obj, ...)
{
    ret <- callNextMethod()
    if (!is.null(ret[["set.x"]]))
    {
        # remove duplicate set column resulting from merging peak lists and fragInfo
        setnames(ret, "set.x", "set")
        ret[, set.y := NULL]
    }
    return(ret[])
})

setMethod("addFormulaScoring", "compoundsSet", function(compounds, formulas, updateScore,
                                                        formulaScoreWeight)
{
    checkmate::assertClass(formulas, "formulasSet")
    
    setsInBoth <- intersect(sets(compounds), sets(formulas))
    setsInComps <- sets(compounds)
    if (length(setsInBoth) < length(setsInComps))
        warning(paste("Following sets not present in formulas:",
                      paste0(setdiff(setsInComps, setsInBoth), collapse = ", ")))
    
    unsetFormulas <- sapply(setsInBoth, unset, obj = formulas, simplify = FALSE)
    compounds@setObjects[setsInBoth] <- mapply(setObjects(compounds)[setsInBoth], unsetFormulas,
                                               FUN = addFormulaScoring, SIMPLIFY = FALSE,
                                               MoreArgs = list(updateScore = updateScore,
                                                               formulaScoreWeight = formulaScoreWeight))
    compounds <- syncCompoundsSetObjects(compounds, TRUE)
    
    return(compounds)
})

generateCompoundsSet <- function(fGroupsSet, MSPeakListsSet, generator, ..., setThreshold)
{
    checkmate::assertNumber(setThreshold, lower = 0, finite = TRUE)
    msplArgs <- assertAndGetMSPLSetsArgs(fGroupsSet, MSPeakListsSet)
    
    unsetFGroupsList <- sapply(sets(fGroupsSet), unset, obj = fGroupsSet, simplify = FALSE)
    setObjects <- mapply(unsetFGroupsList, msplArgs, adducts(fGroupsSet),
                         FUN = function(fg, mspl, a) generator(fGroups = fg, MSPeakLists = mspl[[1]], adduct = a, ...),
                         SIMPLIFY = FALSE)
    
    # update fragInfos
    for (s in names(setObjects))
    {
        for (fg in groupNames(setObjects[[s]]))
        {
            pl <- copy(MSPeakListsSet[[fg]][["MSMS"]]); pl[, PLIndex := seq_len(.N)]; pl <- pl[set == s]
            ct <- setObjects[[s]]@compounds[[fg]]
            ct[, fragInfo := lapply(fragInfo, function(fi)
            {
                fi <- copy(fi) # BUG: avoid warning that somehow was incorrectly copied (invalid .internal.selfref)
                if (nrow(fi) == 0)
                {
                    # otherwise it will be assigned as empty list, which messes up merging elsewhere
                    fi[, PLIndexSet := numeric()]
                }
                else
                    fi[, PLIndexSet := sapply(mz, function(fimz) pl[which.min(abs(fimz - mz))][["PLIndex"]])]
                fi[, set := s]
                return(fi)
            })]
            setObjects[[s]]@compounds[[fg]] <- ct            
        }
    }
    
    cons <- makeCompoundsSetConsensus(setObjects, names(fGroupsSet), setThreshold)
    sc <- makeCompoundsSetScorings(setObjects, names(fGroupsSet))
    
    return(compoundsSet(adducts = adducts(fGroupsSet), setObjects = setObjects,
                        setThreshold = setThreshold, origFGNames = names(fGroupsSet),
                        compounds = cons, scoreTypes = sc$scTypes, scoreRanges = sc$scRanges,
                        algorithm = makeSetAlgorithm(setObjects)))
}


compoundsUnset <- setClass("compoundsUnset", contains = "compounds")
setMethod("unset", "compoundsSet", function(obj, set)
{
    assertSets(obj, set, FALSE)
    obj <- obj[, sets = set]
    
    cList <- lapply(compoundTable(obj), copy)
    cList <- lapply(cList, data.table::set, j = c("set", "setCoverage"), value = NULL)
    
    return(compoundsUnset(compounds = cList, scoreTypes = obj@scoreTypes, scoreRanges = obj@scoreRanges,
                          algorithm = paste0(algorithm(obj), "_unset")))
})
